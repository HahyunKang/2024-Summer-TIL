## 클래스, 오브젝트, 인스턴스

---

### 클래스란?

- 개념 : 객체를 만들어 내기 위한 설계도 혹은 틀
- 연관되어 있는 변수와 메서드의 집합
- 객체지향== 클래스??
  - 클래스가 매우 중요한 구성요소인 것은 맞지만, 핵심을 이루는 중심 개념은 아니다.
  - 클래스의 관점이란,  메시지를 주고받는 객체의 관점으로 봐야한다. 객체지향 그 자체를 의미하는 것이 아니다.

### 오브젝트(객체)란?

- 개념: 소프트웨어 세계에 구현할 대상
- 클래스에 선언된 모양 그대로 생성된 실체
- 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.

### 객체와 추상화

### - 추상화

어떤 양상, 세부 사항, 구조를 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법

복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다.

- 첫 번째 차원은 **구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화**를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 **세부 사항을 제거**함으로써 단순하게 만드는 것이다.

객체지향 패러다임의 중심에는 구체적이고 실체적인 객체가 존재하지만, 수많은 객체를 개별적인 단위로 구분하는 것은 부족하다!

—> 공통적인 특성을 기준으로 객체를 여러 그룹으로 묶어 동시에 다뤄야 하는 가짓수를 줄여야 한다.

공통점을 기반으로 객체들을 묶기 위한 그릇을 **개념**이라 한다.

그리고, 객체에 어떤 개념을 적용하여 개념 그룹 일원이 될 때, 객체를 그 개념의 **인스턴스**라고 한다.

### 인스턴스란?

- 개념 : 설계도를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체
- 객체를 소프트웨어에 실체화하면 그것을 ‘인스턴스’라 부른다.

```kotlin
//클래스
class Animal{
}

fun main{
    //객체
   var cat : Animal
   var dog : Animal
  //인스턴스화 
   cat = Animal()
   dog = Animal()

}
```

## 코틀린 open class

---

자바에서는 클래스에 final이 붙지 않으면 모든 다른 클래스에서 사속이 가능하다. 하지만, 코틀린에서는 클래스와 메서드가 기본적으로 final이다.

따라서 어떤 클래스의 상속을 허용하고자 하면, 해당 클래스 앞에 open 변경자를 붙여야 한다. 또한, 오버라이드를 허용하고 싶은 메서드나 프로퍼티 앞에도 open 변경자를 붙여야 한다.

그렇다면 abstract 클래스나 함수랑은 무슨 차이가 있을까?

abstract 클래스는  **대략적인 설계의 명세**와 **공통의 기능**을 구현한 클래스이다. 즉, **구체적이지 않은 것**이다. abstract class 를 상속하는  하위 클래스는 추상 클래스의 내용을 더 **구체화** 해야 한다.

추상 클래스에서 abstract로 정의한 프로퍼티나 메소드들은 자식 클래스에서 반드시 재정의되어야한다. “**반드시**”라는 용어가 중요하다.  추상 클래스는 open 키워드를 사용하지 않아도 된다. open class는 상속을 “**허용**”하는 것이기 때문에, 서브 클래스에서 상속을 하든 안하든 자유이다. 하지만, 추상 클래스에 정의된 추상 함수들은 무조건 재정의가 필요하다.

## 동적 바인딩 & 다형성

---

다형성은 컴파일 타임 다형성과 런타임 다형성으로 구분된다.

컴파일 타임 다형성은 오버로딩으로 구현된다. 오버로딩은 하나의 메서드 이름에 여러 타입에 따른 구현을 다르게 과적하는 것으로 연결지을 수 있다. 아래의 예시를 통해 이해해보자면,

```jsx
class Account(var balance: Double) {
    fun deposit(amount: Int) {
        balance += amount
    }

    fun deposit(amount: Double) {
        balance += amount
    }
}

fun main() {
    val account = Account(3000.0)
    println(account.balance)
    account.deposit(5000)
    println(account.balance)
    account.deposit(2000.32)
    println(account.balance)
}
/*결과:
3000.0
8000.0
10000.32
*/
```

위의 예시에서 Account클래스는 계좌를 뜻하고, 객체를 생성할 때 Double타입인 balance를 입력받는다. 그리고 Account 클래스는 함수 두개를 갖는데, 두 함수 모두 이름이 deposit이다. 그러나 하나는 Int타입을 인자로 받는 함수이고, 다른 하나는 Double타입을 인자로 받는 함수이다. 즉 같은 함수이름으로 여러 인자 타입을 받을 수 있는 것이다. **Overload라는 개념은 같은 이름의 메소드가 다양한 인자를 받을 수 있게 정의된 것을 말한다.** 

Overload를 할 수 있는 기준이 되는 것은 메서드 시그니처(method signature)로, 메서드 시그니처는 **메서드 이름과 파라미터의 순서, 타입, 개수**를 의미한다.

런타임 다형성은 런타임에 수행된다. 런타임 다형성은 하나의 베이스 클래스 타입 변수를 이용해 다양한 형태를 보일 수 있는 것이다.

```kotlin
open class Parent() {
    open fun whoAmI(): String {
        return "I am a parent"
    }
}

class Child() : Parent() {
    override fun whoAmI(): String {
        return "I am a child"
    }
    fun hi() {
       return "hi"
    }
}

class Child2(): Parent(){
    override fun whoAmI(): String {
        return "I am a child2"
    }
}
fun main() {
    val p: Parent = Child()
    println(p.whoAmI())

    val p2: Parent = Child2()
    println(p2.whoAmI())
    
    println(p.hi())
}
//결과 : 
I am a child
I am a child2
```

Child 클래스가 Parent 클래스를 상속받고, Parent에 있는 whoAmI()함수를 **override**했다. 메인 함수에서 변수 p를 Parent로 선언했지만, Child객체를 가리키도록 했다.  **p는 Parent 타입인데, 실행결과 p의 whoAmI()함수를 호출했을 때 Child의 메서드가 호출된 것**이다. p2에 대한 결과도 마찬가지이다. **Runtime polymorphism은 하나의 베이스 클래스 타입으로 다양한 자료형의 메소드를 불러올 수 있다는 개념이다.**

즉, p1과 p2의 참조 변수 타입은 Parent 지만, p1과 p2는 각각 Child 와 Child2 객체를 참조한다. 실제 객체의 타입에 따라 적절한 메서드가 호출되는 것이다. 이는 다형성을 통해 가능하게 된다.

그러면 왜 런타임 다형성일까?

컴파일러는 참조 변수의 선언된 타입에 따라 그 변수가 호출할 수 있는 메서드와 접근할 수 있는 필드를 확인하다. 컴파일러는 객체의 실제 타입을 알지 못하고, 참조 변수 타입만을 기준으로 코드를 검사한다. 예를 들어, 위 예시에서 컴파일러는 Parent 타입의 메서드와 필드만을 확인한다.

그렇다면 런타임일 때는, 참조 변수가 실제로 어떤 객체를 가리키고 있는지가 결정된다. 이 때, 실제 객체의 타입에 따라 적절한 메서드가 호출되는데, 이를 **동적 바인딩**이라 한다.

## 다운 캐스팅

---

위의 예시에서 p.hi() 를 출력하면 어떤 결과가 나올까

컴파일 오류가 뜰 것이다. p는 Parent 타입으로 선언되었다. 따라서, Parent 클래스에서 정의된 메서드와 필드만 접근할 수 있도록 제한한다.  컴파일러는 p를 Parent 타입으로 간주하기 때문에, hi() 메서드를 호출할 수 없다.

p가 hi 메서드를 호출하고자 한다면, 타입 캐스팅이 필요하다. 타입 캐스팅 연산자에는 is , as가 있다.

as : 변수를 호환되는 자료형으로 변환해주는 캐스팅 연산자로, 사용 즉시 자료형을 변환해주며 **변환된 자료형을 반환**할 수도 있다.

is : 변수가 자료형에 호환되는지를 먼저 **체크한 후 변환**해주는 캐스팅 연산자로, **조건문 내에서 사용**되는 특징이 있다.

main 함수에  아래와 같이  is를 통해 여부를 확인하고 hi메서드를 호출하면 정상적으로 호출된다. is는 조건문 안에서만 잠시 다운캐스팅된다.

다음은 p as Child라는 구문으로 다운 캐스팅한 것을 p3 에 할당하고 함수를 호출한다면, 정상적으로 호출되는 것을 확인할 수 ㅇㅆ다.

```kotlin
if(p is Child){
   p.hi()
}

var p3 = p as Child
p3.hi()
```

- 서로 다른 객체들이 다형성을 만족시킨다는 것은 **객체들이 동일한 책임을 공유한다는 것**을 의미
- 메시지 송신자의 관점에서 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게 한다.
- 대체 가능성 → 설계를 유연하고 재사용 가능하게 만든다.

## this vs super

---

**`this` 키워드:현재 클래스의 인스턴스를 참조.클래스 내부에서 자신의 멤버에 접근하거나, 다른 생성자를 호출할 때 사용.**

**`super` 키워드:상위 클래스의 인스턴스를 참조. 상위 클래스의 메서드나 프로퍼티에 접근할 때 사용**